#compdef paint
# Zsh completion for: paint
#
# Features:
# - Stops suggesting tokens AFTER `--`
# - Smarter `bright`: after `bright`, only suggests colors
# - Completes --border colors
# - Includes all paint options (color mode, escapes stdin, join, completion, table, box)

local -a opts styles color_names color_nums bright_nums join_modes color_modes
local expl

opts=(
  '--ansi[Use ANSI escape codes (default)]'
  '--tput[Use tput/terminfo sequences]'
  '-e[Append newline (echo-like)]'
  '--echo[Append newline (echo-like)]'
  '-t[Print token/color tables and exit]'
  '--table[Print token/color tables and exit]'
  '--join=[Delimiter when joining stdin + suffix text]:join mode:(newline space none)'
  '--escapes-stdin[Interpret backslash escapes from stdin]'
  '--color=[Color output mode]:mode:(always auto never)'
  '--force-color[Force color output (same as --color always)]'
  '--no-color[Disable color output (same as --color never)]'
  '--box[Draw a border box around the rendered text]'
  '--border=[Border color token for --box]:border color:->border'
  '--completion=[Print completion script]:shell:(zsh)'
  '-fg[Next color applies to foreground (default)]'
  '--foreground[Next color applies to foreground (default)]'
  '-bg[Next color applies to background]'
  '--background[Next color applies to background]'
  '-h[Show help]'
  '--help[Show help]'
)

styles=(
  'bold:enable bold'
  'dim:enable dim'
  'italic:enable italic'
  'underline:enable underline'
  'blink:enable blink'
  'reverse:enable reverse video'
  'invis:enable invisible'
  '--bold:enable bold'
  '--dim:enable dim'
  '--italic:enable italic'
  '--underline:enable underline'
  '--blink:enable blink'
  '--reverse:enable reverse video'
  '--invis:enable invisible'
)

color_names=(black red green yellow blue magenta cyan white)
color_nums=(0 1 2 3 4 5 6 7)
bright_nums=(8 9 10 11 12 13 14 15)
join_modes=(newline space none)
color_modes=(always auto never)

_paint_has_double_dash() {
  local i
  for i in {2..$#words}; do
    [[ ${words[i]} == -- ]] && return 0
  done
  return 1
}

_paint_colors_describe() {
  local -a items
  items=(
    ${color_names[@]/%/:color name}
    ${color_nums[@]/%/:color code}
    ${bright_nums[@]/%/:bright color code}
  )
  _describe -t colors 'color' items -V
}

if _paint_has_double_dash; then
  _arguments -s -S $opts '*:text: _default'
  return 0
fi

_arguments -s -S \
  $opts \
  '*:token or text:->tok' && return 0

case $state in
  tok)
    if [[ ${words[CURRENT-1]} == --join ]]; then
      _describe -t join_modes 'join mode' join_modes
      return 0
    fi
    if [[ ${words[CURRENT-1]} == --color ]]; then
      _describe -t color_modes 'color mode' color_modes
      return 0
    fi
    if [[ ${words[CURRENT-1]} == --border ]]; then
      _paint_colors_describe
      return 0
    fi
    if [[ ${words[CURRENT-1]} == bright ]]; then
      _paint_colors_describe
      return 0
    fi

    local -a token_suggestions
    token_suggestions=(
      'bright:make next color bright'
      '-:read stdin explicitly (as text)'
      '--:end tokens/options (treat rest as text)'
      $styles
      '-fg:foreground target'
      '--foreground:foreground target'
      '-bg:background target'
      '--background:background target'
      ${color_names[@]/%/:color name}
      ${color_nums[@]/%/:color code}
      ${bright_nums[@]/%/:bright color code}
    )

    _describe -t tokens 'token' token_suggestions -V
    ;;
  border)
    _paint_colors_describe
    ;;
esac
