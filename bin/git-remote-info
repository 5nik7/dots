#!/usr/bin/env bash

if [ -t 1 ]; then
  ESC=$(printf '\033')
  C_RESET="${ESC}[0m"
  C_BOLD="${ESC}[1m"
  C_DIM="${ESC}[2m"
  C_ITALIC="${ESC}[3m"
  C_UNDERLINE="${ESC}[4m"
  C_REVERSE="${ESC}[7m"
  C_BLACK="${ESC}[30m"
  C_RED="${ESC}[31m"
  C_GREEN="${ESC}[32m"
  C_YELLOW="${ESC}[33m"
  C_BLUE="${ESC}[34m"
  C_MAGENTA="${ESC}[35m"
  C_CYAN="${ESC}[36m"
else
  C_RESET='' C_BOLD='' C_DIM='' C_ITALIC='' C_UNDERLINE='' C_REVERSE='' C_BLACK='' C_RED='' C_GREEN='' C_YELLOW='' C_BLUE='' C_MAGENTA='' C_CYAN=''
fi

usage() {
  cat <<EOF
${C_BOLD}${C_CYAN}git-remote-info${C_RESET}

${C_BOLD}Usage:${C_RESET}
${C_CYAN} git-remote-info${C_RESET} ${C_YELLOW}[path] [remote]${C_RESET} ${C_GREEN}[flags]${C_RESET}
${C_CYAN} git-remote-info${C_RESET} ${C_GREEN}-h | --help${C_RESET}

${C_BOLD}Scope flags:${C_RESET}
${C_GREEN} --default${C_RESET}
${C_GREEN} -a${C_RESET}, ${C_GREEN}--all${C_RESET}
${C_GREEN} -I${C_RESET}, ${C_GREEN}--icon${C_RESET}       icon for host
${C_GREEN} -s${C_RESET}, ${C_GREEN}--scheme${C_RESET}     scheme
${C_GREEN} -H${C_RESET}, ${C_GREEN}--host${C_RESET}       host
${C_GREEN} -o${C_RESET}, ${C_GREEN}--owner${C_RESET}      owner
${C_GREEN} -r${C_RESET}, ${C_GREEN}--repo${C_RESET}       repo (no .git)

${C_BOLD}Formatting flags:${C_RESET}
${C_GREEN} -v${C_RESET}, ${C_GREEN}--value${C_RESET}      values only
${C_GREEN} -0${C_RESET}, ${C_GREEN}--null${C_RESET}       NUL-delimited output
${C_GREEN} --join${C_RESET} ${C_YELLOW}SEP${C_RESET}   join outputs with SEP

${C_BOLD}Notes:${C_RESET}
  • Clustered short flags supported: ${C_CYAN}-orv${C_RESET}, ${C_CYAN}-aH0${C_RESET}

Exit codes:
  0 success / usage shown
  2 git missing / repo missing / bad args
  3 parse error
EOF
}

fail() {
  code=$1
  shift
  printf '%s\n' "${C_RED}$*${C_RESET}" >&2
  exit "$code"
}

command -v git >/dev/null 2>&1 || fail 2 "error: git not found"

# No-arg behavior
if [ $# -eq 0 ] && ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  usage
  exit 0
fi

is_remote=''
cwd=$(pwd)

path="$cwd"
remote='origin'

want_icon=false
want_i=false want_s=false want_h=false want_o=false want_r=false
want_any=false

want_kwy=false want_value=true want_null=false want_join=false join_sep=''

icon_explicit=false

set_scope_default() {
  want_s=true
  want_h=true
  want_o=true
  want_r=true
  want_any=true
}

set_scope_all() {
  want_icon=true
  want_s=true
  want_h=true
  want_o=true
  want_r=true
  want_any=true
}

apply_short_flag() {
  c=$1
  case "$c" in
  h)
    usage
    exit 0
    ;;
  a) set_scope_all ;;
  s)
    want_s=true
    want_any=true
    ;;
  H)
    want_h=true
    want_any=true
    ;;
  o)
    want_o=true
    want_any=true
    ;;
  r)
    want_r=true
    want_any=true
    ;;
  i)
    want_icon=true
    want_any=true
    ;;
  k) want_key=true ;;
  v) want_value=true ;;
  0) want_null=true ;;
  *) fail 2 "unknown option: -$c" ;;
  esac
}

while [ $# -gt 0 ]; do
  case "$1" in
  -h | --help)
    usage
    exit 0
    ;;
  --default) set_scope_default ;;
  -a | --all) set_scope_all ;;

  --scheme)
    want_s=true
    want_any=true
    ;;
  --host)
    want_h=true
    want_any=true
    ;;
  --owner)
    want_o=true
    want_any=true
    ;;
  --repo)
    want_r=true
    want_any=true
    ;;
  --icon)
    want_icon=true
    want_any=true
    ;;
  --key) want_key=true ;;
  --null) want_null=true ;;
  --join)
    shift
    [ $# -gt 0 ] || fail 2 "--join needs a separator"
    join_sep=$1
    want_join=true
    ;;

  -[!-]*)
    flags=${1#-}
    while [ -n "$flags" ]; do
      c=$(printf '%s' "$flags" | cut -c1)
      flags=$(printf '%s' "$flags" | cut -c2-)
      apply_short_flag "$c"
    done
    ;;

  --*) fail 2 "unknown option: $1" ;;

  *)
    if [ "$path" = "$cwd" ]; then
      path=$1
    elif [ "$remote" = "origin" ]; then
      remote=$1
    else
      fail 2 "too many positional args: $1"
    fi
    ;;
  esac
  shift
done

# default scope == --default
if [ "$want_any" = false ]; then
  set_scope_default
fi

git -C "$path" rev-parse --is-inside-work-tree >/dev/null 2>&1 ||
  fail 2 "not a git repo: $path"

# ---- starship-style vars + fallback ----
GIT_REMOTE=$(git -C "$path" remote get-url "$remote" 2>/dev/null)
if [ -z "$GIT_REMOTE" ]; then
  GIT_REMOTE=$(git -C "$path" ls-remote --get-url 2>/dev/null0)
fi

# icon (your rules)
if [ -z "$GIT_REMOTE" ]; then
  GIT_REMOTE_SYMBOL=""
elif printf '%s\n' "$GIT_REMOTE" | grep -qi 'github'; then
  GIT_REMOTE_SYMBOL="󰊤"
elif printf '%s\n' "$GIT_REMOTE" | grep -qi 'gitlab'; then
  GIT_REMOTE_SYMBOL=""
elif printf '%s\n' "$GIT_REMOTE" | grep -qi 'bitbucket'; then
  GIT_REMOTE_SYMBOL=""
elif [ -n "$GIT_REMOTE" ]; then
  GIT_REMOTE_SYMBOL=""
else
  GIT_REMOTE_SYMBOL=""
fi

if printf '%s\n' "$GIT_REMOTE" | grep -Eq '^(ssh://|[^@]+@[^:/]+[:/])'; then
  is_ssh=true
else
  is_ssh=false
fi

scheme=unknown
if printf '%s\n' "$GIT_REMOTE" | grep -Eq '^[a-zA-Z][a-zA-Z0-9+.-]*://'; then
  scheme=https
elif [ "$is_ssh" = true ]; then
  scheme=ssh
fi

# host
host=$(printf '%s\n' "$GIT_REMOTE" | sed -n \
  -e 's#^[^:]*://\([^/]\+\)/.*#\1#p' \
  -e 's#^[^@]*@\([^:/]\+\)[:/].*#\1#p')

# owner + repo (repo sans .git)
set -- $(printf '%s\n' "$GIT_REMOTE" | sed -n 's#.*[/:]\([^/]\+\)/\([^/]\+\)#\1 \2#p')
owner=$1
repo=${2%.git}

format_token() {
  k=$1 v=$2
  if [ "$want_key" = true ]; then
    printf "%s=%s" "$k" "$v"
  else
    printf "%s" "$v"
  fi
}

emit_token() {
  tok=$1
  if [ "$want_join" = true ]; then
    joined=${joined:+$joined$join_sep}$tok
  else
    if [ "$want_null" = true ]; then
      printf '%s\0' "$tok"
    else
      printf '%s\n' "$tok"
    fi
  fi
}

joined=''

[ "$want_icon" = true ] && emit_token "$(format_token icon "$GIT_REMOTE_SYMBOL")"
[ "$want_s" = true ] && emit_token "$(format_token scheme "$scheme")"
[ "$want_h" = true ] && emit_token "$(format_token host "$host")"
[ "$want_o" = true ] && emit_token "$(format_token owner "$owner")"
[ "$want_r" = true ] && emit_token "$(format_token repo "$repo")"

if [ "$want_join" = true ]; then
  if [ "$want_null" = true ]; then
    printf '%s\0' "$joined"
  else
    printf '%s\n' "$joined"
  fi
fi
