#!/usr/bin/env bash

BOLD="$(tput bold 2>/dev/null || printf '')"
GREY="$(tput setaf 7 2>/dev/null || printf '')"
BLACK="$(tput setaf 8 2>/dev/null || printf '')"
UNDERLINE="$(tput smul 2>/dev/null || printf '')"
RED="$(tput setaf 1 2>/dev/null || printf '')"
GREEN="$(tput setaf 2 2>/dev/null || printf '')"
YELLOW="$(tput setaf 3 2>/dev/null || printf '')"
BLUE="$(tput setaf 4 2>/dev/null || printf '')"
MAGENTA="$(tput setaf 5 2>/dev/null || printf '')"
CYAN="$(tput setaf 6 2>/dev/null || printf '')"
NO_COLOR="$(tput sgr0 2>/dev/null || printf '')"

error() {
  printf '\n %s\n\n' "${RED}x ERROR: $*${NO_COLOR}" >&2
}

warn() {
  printf '\n %s\n\n' "${YELLOW}! WARNING: $*${NO_COLOR}"
}

logo() {
  echo "${BLUE}$*${NO_COLOR}"
}

info() {
  printf ' %s\n' "${GREEN}$*${NO_COLOR}"
}

flag() {
  printf "  %-28s %s\n" "${BOLD}${CYAN}$1${NO_COLOR}" " ${GREEN}$2${NO_COLOR}"
}

usage() {
  while [ "$#" -gt 0 ]; do
    case "$1" in
    header)
      local header="
 █▀▀▀▄ ▄▀▀▀▄ █  ▄▀
 █▀▀▀▄ █▀▀▀█ █▀▀▄
 ▀▀▀▀  ▀   ▀ ▀   ▀"
      logo "${header}"
      info "Utility for backing up your files."
      info "usage: ${BLUE}${BOLD}bak${NO_COLOR} ${CYAN}[options]${NO_COLOR} <file|dir> [more files/dirs...]"
      echo
      break
      ;;
    esac
  done
  info "Options:"
  flag "-h, --help" "Displays help"
  flag "-s, --store" "Place backups into ~/.bakstore"
  flag "-y, --yes" "Auto yes to prompts"
  echo
}

bak() {
  # No args?
  [ "$#" -gt 0 ] || {
    usage header
    return 1
  }

  # Flags
  local store_mode=0 auto_yes=0
  local args=()

  # Parse flags
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      usage header
      return 0
      ;;
    -s | --store) store_mode=1 ;;
    -y | --yes) auto_yes=1 ;;
    --)
      shift
      args+=("$@")
      break
      ;;
    -*)
      error "unknown option '${BOLD}${MAGENTA}${1}${NO_COLOR}${RED}'"
      usage
      return 1
      ;;
    *) args+=("$1") ;;
    esac
    shift
  done

  # Need at least one path to back up
  [ "${#args[@]}" -gt 0 ] || {
    usage header
    return 1
  }

  # Portable yes/no prompt function (works in bash/zsh/dash; handles no TTY)
  _bak_confirm() {
    # $1: prompt
    local reply
    if [ "$auto_yes" -eq 1 ]; then
      return 0
    fi
    if [ -t 0 ]; then
      printf "%s" "$1"
      IFS= read -r reply
    elif [ -r /dev/tty ]; then
      printf "%s" "$1" >/dev/tty
      IFS= read -r reply </dev/tty
    else
      error "cannot prompt (no TTY). Use --yes to auto-create."
      return 2
    fi
    case "$reply" in
    [Yy] | [Yy][Ee][Ss]) return 0 ;;
    *) return 1 ;;
    esac
  }

  # If --store, ensure ~/.bakstore exists (prompt if missing)
  local store_dir
  if [ "$store_mode" -eq 1 ]; then
    store_dir="$HOME/.bakstore"
    if [ ! -d "$store_dir" ]; then
      if _bak_confirm "~/.bakstore does not exist. Create it now? [y/N]: "; then
        if ! mkdir -p -- "$store_dir"; then
          error "failed to create '$store_dir'"
          return 1
        fi
      else
        error "store directory not created; aborting."
        return 1
      fi
    fi
  fi

  # Backup loop
  for src in "${args[@]}"; do
    if [ ! -e "$src" ]; then
      error "'${BOLD}${MAGENTA}${src}${NO_COLOR}${RED}' does not exist"
      continue
    fi

    # Skip if already a .bak.
    case "$src" in
    *.bak.*) continue ;;
    esac

    local ts bakname bakpath
    ts="$(date '+%F_%T' | sed 's/:/-/g')" # e.g., 2025-09-25_14-03-07
    bakname="$(basename "$src").bak.${ts}"
    if [ "$store_mode" -eq 1 ]; then
      bakpath="$store_dir/$bakname"
    else
      bakpath="${src}.bak.${ts}"
    fi

    # Avoid collisions (file or dir), retry with new timestamp
    while [ -e "$bakpath" ]; do
      warn "'$bakpath' already exists, retrying..."
      sleep 1
      ts="$(date '+%F_%T' | sed 's/:/-/g')"
      bakname="$(basename "$src").bak.${ts}"
      if [ "$store_mode" -eq 1 ]; then
        bakpath="$store_dir/$bakname"
      else
        bakpath="${src}.bak.${ts}"
      fi
    done

    cp -av -- "$src" "$bakpath"
  done
}

bak "$@"
