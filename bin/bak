#!/usr/bin/env bash

declare -r esc=$'\033'
declare -r c_reset="${esc}[0m"
declare -r bold="${esc}[1m"
declare -r dim="${esc}[2m"
declare -r italic="${esc}[3m"
declare -r underline="${esc}[4m"
declare -r rev="${esc}[7m"
declare -r fg_black="${esc}[1;30m"
declare -r fg_red="${esc}[1;31m"
declare -r fg_green="${esc}[1;32m"
declare -r fg_yellow="${esc}[1;33m"
declare -r fg_darkblue="${esc}[0;34m"
declare -r fg_blue="${esc}[1;34m"
declare -r fg_magenta="${esc}[1;35m"
declare -r fg_cyan="${esc}[1;36m"
declare -r fg_white="${esc}[1;37m"
declare -r trashico=""
declare -r arrowico_l="<-"
declare -r arrowico_r="->"
declare -r arrowcolor="${fg_black}"
declare -r errico=""
declare -t errcolor="${fg_red}"
declare -r warnico=""
declare -t warncolor="${fg_yellow}"
declare -r trashcolor="${fg_green}"
declare -r dircolor="${fg_darkblue}"

BOLD="$(tput bold 2>/dev/null || printf '')"
UNDERLINE="$(tput smul 2>/dev/null || printf '')"
ITALIC="$(tput sitm 2>/dev/null || printf '')"
DIM="$(tput dim 2>/dev/null || printf '')"
INVERT="$(tput rev 2>/dev/null || printf '')"
BLINK="$(tput blink 2>/dev/null || printf '')"
INVIS="$(tput invis 2>/dev/null || printf '')"
GREY="$(tput setaf 7 2>/dev/null || printf '')"
BLACK="$(tput setaf 8 2>/dev/null || printf '')"
RED="$(tput setaf 1 2>/dev/null || printf '')"
GREEN="$(tput setaf 2 2>/dev/null || printf '')"
YELLOW="$(tput setaf 3 2>/dev/null || printf '')"
BLUE="$(tput setaf 4 2>/dev/null || printf '')"
DARKBLUE="$(tput setaf 12 2>/dev/null || printf '')"
MAGENTA="$(tput setaf 5 2>/dev/null || printf '')"
CYAN="$(tput setaf 6 2>/dev/null || printf '')"
NO_COLOR="$(tput sgr0 2>/dev/null || printf '')"

output() {
  printf ' %s\n' "$*"
}

error() {
  printf ' %s\n' "${errcolor}${errico} $*${NO_COLOR}" >&2
}

warn() {
  printf ' %s\n' "${warncolor}${warnico} $*${NO_COLOR}"
}

info() {
  printf ' %s\n' "${GREY}${DIM}$*${NO_COLOR}"
}

disc() {
  printf ' %s\n' "${GREEN}$*${NO_COLOR}"
}

logo() {
  echo "${MAGENTA}$*${NO_COLOR}"
}

flag() {
  printf "  %-28s %s\n" "${BOLD}${CYAN}$1${NO_COLOR}" " ${GREEN}$2${NO_COLOR}"
}

usage() {
  while [ "$#" -gt 0 ]; do
    case "$1" in
    header)
      local header="
 █▀▀▀▄ ▄▀▀▀▄ █  ▄▀
 █▀▀▀▄ █▀▀▀█ █▀▀▄
 ▀▀▀▀  ▀   ▀ ▀   ▀"
      logo "${header}"
      disc "Utility for backing up your files"
      info "usage:${NO_COLOR} ${MAGENTA}${BOLD}bak${NO_COLOR} ${CYAN}[options]${NO_COLOR} ${BLUE}<file|dir>${NO_COLOR} ${BLUE}${DIM}[more files/dirs...]${NO_COLOR}"
      echo
      break
      ;;
    esac
  done
  info "Options:"
  flag "-h, --help" "Displays help"
  flag "-s, --store" "Place backups into ~/.bakstore"
  flag "-y, --yes" "Auto yes to prompts"
  flag "-q, --quiet" "Suppress output"
  flag "-v, --verbose" "All the output"
  echo
}

bak() {
  # No args?
  [ "$#" -gt 0 ] || {
    lnbr=''
    usage header
    return 1
  }

  # Flags
  local store_mode=0 auto_yes=0 quiet_mode=0 verbose_mode=0
  local args=()

  # Parse flags
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      usage header
      return 0
      ;;
    -s | --store) store_mode=1 ;;
    -y | --yes) auto_yes=1 ;;
    -q | --quiet)
      quiet_mode=1
      ;;
    -v | --verbose) verbose_mode=1 ;;
    --)
      shift
      args+=("$@")
      break
      ;;
    -*)
      echo
      error "unknown option '${BOLD}${MAGENTA}${1}${NO_COLOR}${RED}'"
      echo
      usage
      return 1
      ;;
    *) args+=("$1") ;;
    esac
    shift
  done

  # Need at least one path to back up
  [ "${#args[@]}" -gt 0 ] || {
    usage header
    return 1
  }

  [ "$quiet_mode" -eq 1 ] || echo

  # Portable yes/no prompt function (works in bash/zsh/dash; handles no TTY)
  _bak_confirm() {
    # $1: prompt
    local reply
    if [ "$auto_yes" -eq 1 ]; then
      return 0
    fi
    if [ -t 0 ]; then
      printf "%s" "$1"
      IFS= read -r reply
    elif [ -r /dev/tty ]; then
      printf "%s" "$1" >/dev/tty
      IFS= read -r reply </dev/tty
    else
      error "cannot prompt (no TTY). Use --yes to auto-create."
      return 2
    fi
    case "$reply" in
    [Yy] | [Yy][Ee][Ss]) return 0 ;;
    *) return 1 ;;
    esac
  }

  # If --store, ensure ~/.bakstore exists (prompt if missing)
  local store_dir
  if [ "$store_mode" -eq 1 ]; then
    store_dir="$HOME/.bakstore"
    if [ ! -d "$store_dir" ]; then
      if _bak_confirm "~/.bakstore does not exist. Create it now? [y/N]: "; then
        if ! mkdir -p -- "$store_dir"; then
          error "failed to create '$store_dir'"
          return 1
        fi
      else
        error "store directory not created; aborting."
        return 1
      fi
    fi
  fi

  # Backup loop
  for src in "${args[@]}"; do
    local srcpath srcdir srcname
    srcpath=$(realpath "$src")
    srcdir=$(dirname "$srcpath" | sed "s|${HOME}|~|")
    srcname=$(basename "$srcpath")

    if [ ! -e "$src" ]; then
      if [ "$quiet_mode" -eq 0 ]; then
        error "'${MAGENTA}${srcdir}/${BOLD}$srcname${NO_COLOR}${RED}' does not exist"
      fi
      continue
    fi

    # Skip if already a .bak.
    case "$src" in
    *.bak.*) continue ;;
    esac

    local ts bakname bakpath
    ts="$(date '+%F_%T' | sed 's/:/-/g')" # e.g., 2025-09-25_14-03-07
    bakname="$(basename "$src").bak.${ts}"
    if [ "$store_mode" -eq 1 ]; then
      bakpath="$store_dir/$bakname"
    else
      bakpath="${src}.bak.${ts}"
    fi

    # Avoid collisions (file or dir), retry with new timestamp
    while [ -e "$bakpath" ]; do
      warn "'$bakpath' already exists, retrying..."
      sleep 1
      ts="$(date '+%F_%T' | sed 's/:/-/g')"
      bakname="$(basename "$src").bak.${ts}"
      if [ "$store_mode" -eq 1 ]; then
        bakpath="$store_dir/$bakname"
      else
        bakpath="${src}.bak.${ts}"
      fi
    done

    if [ "$verbose_mode" -eq 1 ]; then
      cp -av -- "$src" "$bakpath"
    elif [ "$quiet_mode" -eq 1 ]; then
      cp -a -- "$src" "$bakpath"
    else
      cp -a -- "$src" "$bakpath"

      local srcout bakout
      srcout="$(eza --color=always --icons=always --dereference -d "$src" | sed "s|${HOME}|~|")"
      bakout="$(eza --color=always --icons=always --dereference -d "$bakpath" | sed "s|${HOME}|~|")"

      output "$srcout ${arrowcolor}${arrowico_r}${c_reset} $bakout"
    fi
  done
  [ "$quiet_mode" -eq 1 ] || echo
}

bak "$@"
